# filler
For this project, I have created a filler player.
It reads the board and the game pieces placed on the standard output.
Each turn the filler rewrites the board map and includes a new piece to be placed.
In order to place the game piece on the board, the player will have to write it’s coordinates on the standard ouput.
The following format must be used “X Y\n”. The concept is simple: two players gain points by placing on a board, one after the other, the game piece obtained by the game master (in the form of an executable Ruby program). The game ends when the game piece cannot be placed anymore.

### How the game works
At each turn, the filler sends the updated map and a new token to the player concerned.
The player concerned writes on the standard output his or her piece’s coordinates to place it on the board.
The filler sends the map and a new piece to the other player.

### Installing
```
Install the program using makefile
```

### Launching filler

```
./filler_vm, made by Hcao and Abanlin, version 1.1
Usage: ./filler_vm -f path [-i | -p1 path | -p2 path] [-s | -q | -t time]

   -t  --time		set timeout in second
   -q  --quiet		quiet mode
   -i  --interactive	interactive mode(default)
   -p1 --player1	use filler binary as a first player
   -p2 --player2	use filler binary as a second player
   -f  --file		use a map file (required)
   -s  --seed		use the seed number (initialization random) (man srand)
```   

### How the game rolls

```
$>./filler_vm -p1 user1 -p2 user2 -v -f samples/w1.flr
$$$ exec p1 : [user1]
$$$ exec p2 : [user2]
Plateau 14 30:
012345678901234567890123456789
000 ..............................
001 ..............................
002 ..............................
003 ..............................
004 ......X.......................
005 ..............................
006 ..............................
007 ..........................O...
008 ..............................
009 ..............................
010 ..............................
011 ..............................
012 ..............................
013 ..............................
Piece 3 6:
.****.
**....
*.....
<got (O) : [7 24] (7,24)
Plateau 14 30:
012345678901234567890123456789
000 ..............................
001 ..............................
002 ..............................
003 ..............................
004 ......X.......................
005 ..............................
006 ..............................
007 .........................oooo.
008 ........................oo....
009 ........................o.....
010 ..............................
011 ..............................
012 ..............................
013 ..............................
Piece 3 8:
......*.
......**
.......*
<got (X) : [4 0] (4,0)
Plateau 14 30:
012345678901234567890123456789
000 ..............................
001 ..............................
002 ..............................
003 ..............................
004 ......x.......................
005 ......xx......................
006 .......x......................
007 .........................OOOO.
008 ........................OO....
009 ........................O.....
010 ..............................
011 ..............................
012 ..............................
013 ..............................
[...]
== X fin : 175 [1018918090]
== O fin : 168 [1018918090]
```
